import io
from datetime import date, datetime, timezone
import os

from functools import wraps, update_wrapper

import matplotlib.pyplot as plt
import numpy as np
from flask import (Blueprint, Response, flash, redirect, render_template,
                   request, send_from_directory, current_app, make_response)
from flask import session as flask_session
from matplotlib.backends.backend_agg import FigureCanvasAgg as FigureCanvas
from matplotlib.figure import Figure
from sqlalchemy.orm import Query, relationship, sessionmaker

from werkzeug.http import http_date

from .db import db

bp = Blueprint('visualize', __name__, url_prefix="")

# Amount of days we should refresh the visualization
EXPIRE_DAYS = 1
# Amount of months we should go back to visualize
VISUALIZE_MONTHS = 6

def nocache(view):
    @wraps(view)
    def no_cache(*args, **kwargs):
        response = make_response(view(*args, **kwargs))
        response.headers['Last-Modified'] = http_date(datetime.now())
        response.headers['Cache-Control'] = 'no-store, no-cache, must-revalidate, post-check=0, pre-check=0, max-age=0'
        response.headers['Pragma'] = 'no-cache'
        response.headers['Expires'] = '-1'
        return response
        
    return update_wrapper(no_cache, view)


@bp.route("/visualize")
@nocache
def visualize():
    # Make sure the user is userLVL 0 or 1
    user_level: int = flask_session.get("userLVL", default=None)
    visual_image1_png()
    # Rely on short circuit eval here...
    if (user_level is None) or user_level > 1:
        flash("Not authorized")
        # May need to change where we redirect them in the future
        return redirect("/")
    return render_template("visualize.html", role=user_level, title="Visualize")


def visual_image1_png():
    """ 
    This is an image that is dynamically generated by plots from the database.
    This image is a 3x3 subplot of Durations in each stage and overall.
    """
    global EXPIRE_DAYS
    global VISUALIZE_MONTHS
    
    visualization_name = "visual_durations.png"
    # Check if file exists
    if (os.path.exists(os.path.join(current_app.config['UPLOAD_FOLDER'], visualization_name))):
        # Check if the file is under the date required to renew
        if ((date.today() -
            datetime.fromtimestamp(
            os.path.getmtime(os.path.join(
                current_app.config['UPLOAD_FOLDER'], visualization_name)), timezone.utc).date()
             ).days < EXPIRE_DAYS):
            return 
        # File is expired. Remove the old one
        else:
            os.remove(os.path.join(
                current_app.config["UPLOAD_FOLDER"], visualization_name))

    # We have not returned. So must be time to make a new visualization

    # Open a database session
    engine = db.get_db_engine()
    db_session = (sessionmaker(bind=engine))()

    # Pull the last x months of data.
    # This will return a list (of up to x) of the Class MetaInformation (from db.py)
    data_list = db_session.query(db.MetaInformation).\
        order_by(db.MetaInformation.year.desc(), db.MetaInformation.month.desc()).\
        limit(VISUALIZE_MONTHS).all()

    # Close the database like a good boy
    db_session.close()

    # Get the length of our list
    x = len(data_list)

    # create empty numpy arrays to hold our values for visualization
    months = np.empty(x, dtype=object)
    stage1 = np.empty(x, dtype=float)
    stage2 = np.empty(x, dtype=float)
    stage3 = np.empty(x, dtype=float)
    stage4 = np.empty(x, dtype=float)
    stage5 = np.empty(x, dtype=float)
    stage6 = np.empty(x, dtype=float)
    stage7 = np.empty(x, dtype=float)
    total = np.empty(x, dtype=float)

    # Go row by row in our list taken from the database and put them in the arrays
    for row in data_list:
        # We want to put them into the array in reverse. (Using our amount pulled from database)
        # so that the most recent month is to the right of the visualization
        x -= 1
        # Month as an number with 1 leading 0
        months[x] = "{:02d}".format(row.month)
        # Figure out the average by taking total amount / #of animals
        # Make sure each one is not 0 before dividing.
        # 0 Means none of that type were found in that period
        # Stage 1
        if row.animalsCompStage1 != 0:
            stage1[x] = (row.totalDaysCompStage1/row.animalsCompStage1)
        else:
            stage1[x] = None
        # Stage 2
        if row.animalsCompStage2 != 0:
            stage2[x] = (row.totalDaysCompStage2/row.animalsCompStage2)
        else:
            stage1[x] = None
        # Stage 3
        if row.animalsCompStage3 != 0:
            stage3[x] = (row.totalDaysCompStage3/row.animalsCompStage3)
        else:
            stage1[x] = None
        # Stage 4
        if row.animalsCompStage4 != 0:
            stage4[x] = (row.totalDaysCompStage4/row.animalsCompStage4)
        else:
            stage1[x] = None
        # Stage 5
        if row.animalsCompStage5 != 0:
            stage5[x] = (row.totalDaysCompStage5/row.animalsCompStage5)
        else:
            stage1[x] = None
        # Stage 6
        if row.animalsCompStage6 != 0:
            stage6[x] = (row.totalDaysCompStage6/row.animalsCompStage6)
        else:
            stage1[x] = None
        # Stage 7
        if row.animalsCompStage7 != 0:
            stage7[x] = (row.totalDaysCompStage7/row.animalsCompStage7)
        else:
            stage1[x] = None
        # Complete Duration
        if row.totalStagesAmount != 0:
            total[x] = (row.totalStagesLength/row.totalStagesAmount)
        else:
            stage1[x] = None

    # Create a subplot matrix (3x3)
    fig, axs = plt.subplots(3, 3)
    # Add a Title
    fig.suptitle("Average Duration in Stages", fontsize='xx-large')
    # Add a y label
    fig.text(0.5, 0.04, 'Month', ha='center', va='center', fontsize='large')
    # Add a x label
    fig.text(0.06, 0.5, 'Average Duration (Days)', ha='center',
             va='center', rotation='vertical', fontsize='large')
    # Add a note at the bottom left for the date
    fig.text(0, 0, 'Created on {}'.format(date.today()))

    # Set axis plots with our data
    # Stage 1
    axs[0, 0].plot(months, stage1, 'b')
    axs[0, 0].set_title(label="Stage 1", y=1)
    # Stage 2
    axs[0, 1].plot(months, stage2, 'b')
    axs[0, 1].set_title(label="Stage 2", y=1)
    # Stage 3
    axs[0, 2].plot(months, stage3, 'b')
    axs[0, 2].set_title(label="Stage 3", y=1)
    # Stage 4
    axs[1, 0].plot(months, stage4, 'b')
    axs[1, 0].set_title(label="Stage 4", y=1)
    # Stage 5
    axs[1, 1].plot(months, stage5, 'b')
    axs[1, 1].set_title(label="Stage 5", y=1)
    # Stage 6
    axs[1, 2].plot(months, stage6, 'b')
    axs[1, 2].set_title(label="Stage 6", y=1)
    # Stage 7
    axs[2, 0].plot(months, stage7, 'b')
    axs[2, 0].set_title(label="Stage 7", y=1)
    # Stage Total
    axs[2, 1].plot(months, total, 'm')
    axs[2, 1].set_title(label="Full Length", y=1)
    # Unused Axis, so just hide
    axs[2, 2].set_axis_off()

    # Adjust the margins between subplots
    plt.subplots_adjust(wspace=0.25, hspace=1)

    # Convert the graph to a png
    plt.savefig(os.path.join(
                current_app.config['UPLOAD_FOLDER'], visualization_name), dpi=300)
    plt.close()

    return
